# Services Layer Documentation

This directory contains the business logic layer that orchestrates API client operations, caching strategies, and data transformation for the API-Football MCP Server.

## Overview

The services layer acts as an intermediary between the MCP tools and the underlying infrastructure (API client and cache). It provides a clean, high-level interface for data operations while handling cross-cutting concerns like caching, logging, and error handling.

## Service Files

### `data-service.ts` - Core Data Service

The main service class that provides a unified interface for all football data operations.

#### Key Features
- **Unified API**: Single interface for all data types (standings, fixtures, teams, players, etc.)
- **Intelligent Caching**: Automatic cache-aside pattern with configurable TTL per data type
- **Request Correlation**: Request ID tracking for debugging and monitoring
- **Batch Operations**: Support for multiple concurrent requests with concurrency control
- **Health Monitoring**: Built-in health checks for API and cache status

#### Architecture

```typescript
class DataService {
  private apiClient: APIFootballClient
  private cache: LRUCache
  private enableCaching: boolean
  private enableLogging: boolean
}
```

#### Core Methods

**Standings Operations**
- `getStandings(season?, options?)`: Get league standings with automatic caching

**Fixtures Operations**
- `getFixtures(params?, options?)`: Get match fixtures with flexible filtering
- `getLiveFixtures(options?)`: Get live matches with short-term caching

**Team Operations**
- `getTeams(season?, options?)`: Get all teams for a season
- `getTeam(teamId, season?, options?)`: Get specific team information
- `searchTeams(query, season?, options?)`: Search teams by name

**Player Operations**
- `getPlayers(params?, options?)`: Get players with filtering
- `getPlayer(playerId, season?, options?)`: Get specific player information
- `searchPlayers(query, params?, options?)`: Search players by name
- `getSquad(teamId, season?, options?)`: Get team squad

**Match Events**
- `getFixtureEvents(fixtureId, options?)`: Get match events (goals, cards, etc.)

**Utility Operations**
- `clearCache()`: Clear all cached data
- `getCacheStats()`: Get cache performance statistics
- `invalidateCacheByPattern(pattern)`: Remove cache entries by pattern
- `invalidateCacheByType(type)`: Remove all cache entries for a data type
- `healthCheck()`: Check service health status

#### Configuration Options

```typescript
interface DataServiceConfig {
  apiClient: APIFootballClient    // Required: API client instance
  cache: LRUCache                // Required: Cache instance
  enableCaching?: boolean        // Optional: Enable/disable caching (default: true)
  enableLogging?: boolean        // Optional: Enable/disable logging (default: true)
}

interface QueryOptions {
  bypassCache?: boolean          // Skip cache read/write
  cacheTtl?: number             // Override default TTL
  requestId?: string            // Request correlation ID
}
```

## Usage Patterns

### Basic Service Creation
```typescript
import { DataService } from './services/data-service'
import { APIFootballClient } from './lib/api-client/client'
import { LRUCache } from './lib/cache/lru-cache'

const apiClient = new APIFootballClient({ apiKey: 'your-key' })
const cache = new LRUCache({ maxSize: 1000, defaultTtl: 300000 })

const dataService = new DataService({
  apiClient,
  cache,
  enableCaching: true,
  enableLogging: true
})
```

### Simple Data Retrieval
```typescript
// Get current season standings
const standings = await dataService.getStandings()

// Get specific team information
const team = await dataService.getTeam(42, 2023)

// Search for players
const players = await dataService.searchPlayers('Messi', { team: 85 })
```

### Advanced Options
```typescript
// Bypass cache for fresh data
const freshStandings = await dataService.getStandings(2023, {
  bypassCache: true
})

// Use custom cache TTL
const shortCacheFixtures = await dataService.getFixtures({}, {
  cacheTtl: 60000 // 1 minute instead of default
})

// Track request for debugging
const requestId = 'req_123'
const standings = await dataService.getStandings(2023, { requestId })
```

### Batch Operations
```typescript
// Execute multiple requests with concurrency control
const requests = [
  () => dataService.getStandings(2023),
  () => dataService.getFixtures({ season: 2023 }),
  () => dataService.getTeams(2023)
]

const results = await dataService.batchRequest(requests, {
  maxConcurrency: 3,
  requestId: 'batch_001'
})
```

### Health Monitoring
```typescript
// Check service health
const health = await dataService.healthCheck()
console.log({
  apiConnected: health.api.connected,
  rateLimitRemaining: health.api.rateLimitRemaining,
  cacheSize: health.cache.size,
  cacheHitRate: health.cache.hitRate
})
```

## Caching Strategy

### Cache Key Generation
The service uses structured cache keys for efficient lookups:
- Pattern: `{type}:{param1}:{param2}:...`
- Examples:
  - `standings:2023`
  - `fixtures:2023:team:42:from:2023-01-01`
  - `players:team:85:season:2023`

### TTL Policies
Different data types use different cache durations:
- **Historical data** (past seasons): 24 hours
- **Current season data**: 5 minutes
- **Live match data**: 30 seconds
- **Player/team profiles**: 1 hour

### Cache Invalidation
- **Pattern-based**: `invalidateCacheByPattern('standings:*')`
- **Type-based**: `invalidateCacheByType('fixtures')`
- **Manual**: `clearCache()` for complete reset

## Error Handling

### API Errors
The service handles various API error conditions:
- **Network errors**: Automatic retry with exponential backoff
- **Rate limiting**: Respect API rate limits with waiting
- **Invalid responses**: Parse and validate API responses
- **Timeout errors**: Configurable timeouts with fallback

### Cache Errors
Cache failures are handled gracefully:
- **Cache miss**: Fall back to API call
- **Cache write failure**: Continue without caching
- **Cache corruption**: Clear affected entries

### Error Recovery
- **Stale data**: Serve cached data when API is unavailable
- **Partial failures**: Return successful results, log failures
- **Circuit breaker**: Temporarily disable failing operations

## Performance Optimization

### Caching Effectiveness
- **Cache-aside pattern**: Check cache first, load on miss
- **Write-through**: Update cache after successful API calls
- **TTL optimization**: Different TTLs based on data volatility

### Concurrency Control
- **Batch requests**: Process multiple requests efficiently
- **Rate limiting**: Respect API limits automatically
- **Connection pooling**: Reuse HTTP connections

### Memory Management
- **LRU eviction**: Remove least-recently-used entries
- **Size limits**: Prevent unbounded cache growth
- **Cleanup intervals**: Periodic removal of expired entries

## Integration Points

### MCP Tools Integration
Tools use the service for all data operations:
```typescript
// In get-standings.ts
class GetStandingsTool {
  constructor(private dataService: DataService) {}

  async call(request: CallToolRequest) {
    const standings = await this.dataService.getStandings(
      request.params.season,
      { requestId: generateRequestId() }
    )
    return { content: [{ type: 'text', text: JSON.stringify(standings) }] }
  }
}
```

### Logging Integration
All operations are logged with structured context:
```typescript
logger.info('Data service operation', {
  operation: 'getStandings',
  season: 2023,
  requestId: 'req_123',
  cacheHit: true,
  duration: 15
})
```

### Monitoring Integration
Service provides metrics for monitoring:
- Request counts and timing
- Cache hit/miss rates
- Error rates and types
- API rate limit status

## Testing Strategy

### Unit Tests
- Mock API client and cache
- Test individual methods
- Verify error handling
- Check caching logic

### Integration Tests
- Real API integration
- Cache integration
- End-to-end workflows
- Error scenarios

### Performance Tests
- Concurrent request handling
- Memory usage validation
- Cache effectiveness
- Response time benchmarks

## Development Guidelines

### Adding New Operations
1. Add method to DataService class
2. Implement caching logic
3. Add error handling
4. Write comprehensive tests
5. Update documentation

### Cache Policy Changes
1. Update cache key generation
2. Modify TTL policies
3. Test invalidation logic
4. Monitor performance impact

### Error Handling Improvements
1. Identify new error conditions
2. Implement graceful degradation
3. Add appropriate logging
4. Test recovery scenarios